# Copyright 2015 Joakim Nilsson
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import debug as _dbg
import itertools as _it
import inout as _inout
from inout import *
from log import _log


_inout.printDefaultSigFigs()
_inout.setDefaultSigFigs(6)
printDefaultSigFigs()

printVar = _dbg.printVar

def _polishEval(expr, stack = None):
	# Do not modify original expression
	expr = list(expr)
	
	# Default empty stack
	if stack == None:
		stack = []
	
	# If empty expression
	if not expr:
		stack.reverse()
		return stack
	
	# If not empty expression
	else:
		el = expr.pop()
		
		# If operator (function)
		if callable(el):
			expr.append(el(stack.pop(), stack.pop()))
			return (_polishEval(expr, stack))
			
		# If value
		else:
			stack.append(el)
			return _polishEval(expr, stack)

def _parallelRes(res1, res2):
	res1 = float(res1)
	res2 = float(res2)
	if res1 == 0 and res2 == 0:
		return 0
	else:
		return res1 * res2 / (res1 + res2)

def _seriesRes(res1, res2):
	res1 = float(res1)
	res2 = float(res2)
	return res1 + res2

def _getAvailVals(series = 'E6', minVal = 10, maxVal = 10000000):
	# Dictionry with common series
	# TODO: Add more
	# TODO: Calculate these?
	availValsDict = {}
	availValsDict['E6']  = [10.,      15.,      22.,      33.,      47.,      68.     ]
	availValsDict['E12'] = [10., 12., 15., 18., 22., 27., 33., 39., 47., 56., 68., 82.]
	
	# Get basic available values
	if type(series) is str:
		basicAvailVals = availValsDict[series]
	else:
		basicAvailVals = series
	availVals = list(basicAvailVals)
	
	# Append higher order series
	multiplier = 10
	while availVals[-1] <= maxVal:
		availVals  += map(lambda x: x*multiplier, basicAvailVals)
		multiplier *= 10
	
	# Reverse for more efficient list operations
	availVals.reverse()
	basicAvailVals.reverse()
	
	# Append low order series
	divider = 10
	while availVals[-1] >= minVal:
		availVals += map(lambda x: x / divider, basicAvailVals)
		divider   *= 10
	
	# Reverse again for ordered list
	availVals.reverse()
	
	# Filter out too high or too low values
	availVals = filter(lambda x: x <= maxVal, availVals)
	availVals = filter(lambda x: x >= minVal, availVals)
	
	return list(availVals)

def lumpedNetwork(
		target,
		maxNumComps = float('inf'),
		maxAbsError = None,
		maxRelError = None,
		availVals = _getAvailVals('E6'),
		availOps = [_parallelRes, _seriesRes]
	):
	
	# Check so that target is non-zero
	if not target > 0:
		return _stringOrException("Target resistance must be larger than 0.")
	
	# Figure out error mode
	if maxAbsError is None and maxRelError is None:
		maxError = 0
		useRelError = True
	elif not maxAbsError is None and not maxRelError is None:
		return _stringOrException("Can not specify both 'maxAbsError' and 'maxRelError'.")
	elif not maxAbsError is None:
		maxError = maxAbsError
		useRelError = False
	else:
		maxError = maxRelError
		useRelError = True
	
	# Initial values
	bestError = float('inf')
	bestExpr  = None
	
	# For all numbers of components, starting from one up to 'maxNumComps'
	for numComps in _it.count(1):
		_log(1, 'Trying with %i components...' % numComps)
		# For every combination of non-equivalent connections
		DEBUG_count = 0
		for values in _it.combinations_with_replacement(availVals, numComps):
			for ops in _it.product(availOps, repeat = numComps - 1):
				# Insertions generator
				def insertionsGen(ops, lastOp = None):
					# Base case
					if len(ops) == 0:
						yield []
					
					# Recurse
					else:
						curOp = ops[0]
						for insertions in insertionsGen(ops[1:], lastOp = curOp):
							# Avoid redundant insertion variations by not varying operator order in case of two consecutive equal operations
							if curOp == lastOp or curOp == None:
								yield [1] + insertions
							
							# Non-redundant case
							else:
								yield [0] + insertions
								yield [1] + insertions
				
				for insertions in insertionsGen(ops):
					# Initilize expression and insert position
					expr = list(values)
					insertPos = 0
					
					# Insert functions in expression in every valid way except in redundant ways
					for insertion in insertions:
						opList = list(ops)
						expr.insert(insertPos, opList.pop())
						insertPos += insertion + 1
					
					value = _polishEval(expr)[0] # Get value from evaluated expression
					
					# Calculate error
					if useRelError:
						error = abs((target - value) / target) # Division-by-zero safe because target can not be 0
					else:
						error = abs(target - value)
					
					# Remember result if best so far
					if error <= bestError:
						bestError = error
						bestExpr = expr
					
					DEBUG_count += 1
				
		# TODO: Include sign in this
		if useRelError:
			_log(2, 'Best error so far: %s %%' % (_inout.strSci(100*error)))
		else:
			_log(2, 'Best error so far: %s' % (_inout.strSci(error)))
		
		# TODO: Logging
		if bestError <= maxError or numComps == maxNumComps:
			printVar(DEBUG_count)
			return bestExpr
